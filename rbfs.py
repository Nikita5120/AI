# -*- coding: utf-8 -*-
"""RBFS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1FKK9tdyzhCzhwVXknC743KWkn5Zl9HwC
"""

import math

class Node:
    def __init__(self, name, heuristic_value):
        self.name = name
        self.heuristic = heuristic_value
        self.edges = []  # edges (children)
        self.parent = None  # for path reconstruction

    def add_edge(self, node, cost):
        self.edges.append((node, cost))

# Define heuristic values for each node
A = Node("A", 5)
B = Node("B", 3)
C = Node("C", 2)
D = Node("D", 0)  # Goal node
E = Node("E", 4)

# Add edges to the nodes (graph structure)
A.add_edge(B, 1)  # A -> B with cost 1
A.add_edge(C, 3)  # A -> C with cost 3
B.add_edge(D, 1)  # B -> D with cost 1
C.add_edge(E, 1)  # C -> E with cost 1

# Define the RBFS algorithm
def rbfs(node, goal, f_limit, g_value=0):
    if node == goal:
        return g_value  # If the goal is reached, return the cost

    successors = []
    for child, cost in node.edges:
        f_value = g_value + cost + child.heuristic  # F(n) = G(n) + H(n)
        successors.append((child, f_value, cost))

    # Sort successors by their f_value
    successors.sort(key=lambda x: x[1])

    best = math.inf
    for i, (child, f_value, cost) in enumerate(successors):
        if f_value > f_limit:
            return best  # Return the best found so far if above limit

        # Perform RBFS recursively on the best child
        result = rbfs(child, goal, min(f_limit, best), g_value + cost)
        if result < best:
            best = result

    return best

# Function to execute the search
def rbfs_search(start, goal):
    f_limit = start.heuristic  # Set initial f_limit to the heuristic of the start node
    result = rbfs(start, goal, f_limit)
    if result != math.inf:
        print(f"Path found with cost: {result}")
    else:
        print("No path found.")

# Run RBFS search from node A to node D
print("Starting RBFS search from A to D:")
rbfs_search(A, D)

import matplotlib.pyplot as plt
import networkx as nx

# Create a directed graph
G = nx.DiGraph()

# Add nodes
nodes = ['A', 'B', 'C', 'D', 'E']
G.add_nodes_from(nodes)

# Add edges with weights (cost)
edges = [('A', 'B', 1), ('A', 'C', 3), ('B', 'D', 1), ('C', 'E', 1)]
G.add_weighted_edges_from(edges)

# Positions of nodes for better visualization
pos = {
    'A': (0, 0),
    'B': (-1, -1),
    'C': (1, -1),
    'D': (-1, -2),
    'E': (1, -2)
}

# Draw the graph
plt.figure(figsize=(8, 6))
nx.draw(G, pos, with_labels=True, node_size=3000, node_color="lightblue", font_size=12, font_weight="bold", edge_color='gray')

# Add edge labels (costs)
edge_labels = nx.get_edge_attributes(G, 'weight')
nx.draw_networkx_edge_labels(G, pos, edge_labels=edge_labels)

# Display the plot
plt.title("Graph Representation of Nodes and Edges")
plt.show()

